<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="apple-touch-icon" href="/assets/images/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicon-16x16.png"><link rel="icon" href="/assets/images/favicon.ico"><title>Setters vs ngOnChanges: which one is better?</title><meta name="description" content="Listening to Input changes can be done in different ways. But which one should you use?"><meta name="author" content="Giancarlo Buomprisco"><meta property="og:title" content="Setters vs ngOnChanges: which one is better?"><meta property="og:description" content="Listening to Input changes can be done in different ways. But which one should you use?"><meta property="og:locale" content="en"><meta property="og:site_name" content="Angular Bites"><meta property="og:type" content="article"><meta name="twitter:image" property="og:image" content="https://angularbites.com/assets/images/posts/setters-vs-on-changes.png"><meta http-equiv="refresh" content="2;url=https://giancarlobuomprisco.com/angular/setters-vs-ng-on-changes"><meta property="twitter:title" content="Setters vs ngOnChanges: which one is better?"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:creator" content="@gc_psk"><meta property="twitter:description" content="Listening to Input changes can be done in different ways. But which one should you use?"><meta property="og:url" content="https://angularbites.com/setters-vs-ng-on-changes/"><meta property="article:published_time" content="2020-07-30T00:00:00.000Z"><script type="application/ld+json">{
"description": "Listening to Input changes can be done in different ways. But which one should you use?",
"author": { "@type": "Person", "name": "Giancarlo Buomprisco" },
"@type": "BlogPosting",
"url": "https://angularbites.com/setters-vs-ng-on-changes/",
"publisher": {
"@type": "Organization",
"logo": {
"@type": "ImageObject",
"url": "https://angularbites.com/assets/images/logo.png"
},
"name": "Giancarlo Buomprisco"
},
"headline": "Setters vs ngOnChanges: which one is better?",
"datePublished": "2020-07-30T00:00:00.000Z",
"mainEntityOfPage": {
"@type": "WebPage",
"@id": "https://angularbites.com/setters-vs-ng-on-changes/"
},
"@context": "http://schema.org"
}</script><link href="/assets/styles/main.01b26601bd28e56788b1.css" rel="stylesheet"></head><body><meta http-equiv="refresh" content="2;url=https://giancarlobuomprisco.com/angular/setters-vs-ng-on-changes"><div class="container mx-auto pt-8"><header class="flex items-center"><h1 class="text-4xl my-0"><a class="site-name flex items-center" href="/"><img class="logo" alt="Logo" src="/assets/images/logo.png"></a></h1><div class="flex justify-end flex-grow"><nav class="flex main-navigation"><a class="p-4" href="/contacts.html">Contacts</a></nav></div></header><article class="post pt-4"><header class="mb-8"><h1 class="post-title">Setters vs ngOnChanges: which one is better?</h1><div class="block items-center md:flex justify-center"><div class="user-image flex items-center"><a target="_blank" href="https://twitter.com/@gc_psk" class="flex items-center"><img src="/assets/images/giancarlo.jpeg"> <span class="ml-2 text-gray-600 text-sm">@gc_psk</span> </a><span class="text-gray-600 text-400 ml-1">/ July 30, 2020</span></div><div class="mt-2 md:ml-5 md:mt-0"><a href="/tags/angular" class="tag-item text-xs">angular</a></div></div><div class="featured-image mb-8 mt-8 hidden md:block"><img src="/assets/images/posts/setters-vs-on-changes.png"></div></header><section class="pb-3"><p>Getting notified about an Angular component's property changes is normally done in 2 ways:</p><ul><li>adding a setter to the property</li><li>using the <code>ngOnChanges</code> lifecycle hook</li></ul><p>But... is there a best practice?</p><p>This discussion recently came up with my colleagues while trying to establish a standard practice in our codebase. We tried to find objective arguments to understand which one is better.</p><p>As usual, the answer depends on the scenario.</p><h2>Style</h2><p>Style is very much a subjective factor, but using a setter is hands-down my favorite approach. Let's take a look at a common scenario:</p><pre class="language-typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">MyComponent</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> subject$ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token maybe-class-name">Subject</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  @<span class="token function"><span class="token maybe-class-name">Input</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">set</span> <span class="token function">name</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">subject$</span><span class="token punctuation">.</span><span class="token method function property-access">next</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>It's succinct, type-safe, and encourages the usage of Observables. Not much to dislike, imho.</p><p>But can you <strong>not</strong> add a getter?</p><p>Yes. It turns out, Angular does not check the previous value by invoking the getter on the property, but stores its value in its component's logical view.</p><p>If you're interested in reading the source code where this happens, <a href="https://github.com/angular/angular/blob/d1ea1f4c7f3358b730b0d94e65b00bc28cae279c/packages/core/src/render3/bindings.ts#L50">check this out</a>.</p><pre class="language-typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">MyComponent</span></span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token maybe-class-name">OnChanges</span></span> <span class="token punctuation">{</span>
  @<span class="token function"><span class="token maybe-class-name">Input</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>

  <span class="token keyword">private</span> subject$ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token maybe-class-name">Subject</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">ngOnChanges</span><span class="token punctuation">(</span>changes<span class="token operator">:</span> <span class="token maybe-class-name">SimpleChanges</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// changes.name.currentValue is typed as `any`</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">subject$</span><span class="token punctuation">.</span><span class="token method function property-access">next</span><span class="token punctuation">(</span>changes<span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">.</span><span class="token property-access">currentValue</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>The <code>ngOnChanges</code> lifecycle hook, on the contrary, it's not as nice (in my opinion) - and most importantly, is weakly typed.</p><p>Also - it's worth to mention that using setters usually takes less code, which is always a good thing.</p><h2>Performance</h2><p>Does performance change much? At first, we thought that <code>ngOnChanges</code> would be more efficient as being part of Angular's lifecycle hooks, and therefore being aware of when a property changed.</p><p>It turns out, though, that Angular <strong>does only change a property when the binding is a new instance</strong>. Of course, we're taking into account the change detection being <code>OnPush</code>.</p><p>Performance-wise, according to my tests, there isn't a better way, and shouldn't be a factor when deciding which way to go with.</p><h2>Dealing with multiple Inputs</h2><p>The situation changes when taking into account changes on multiple inputs:</p><pre class="language-typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">MyComponent</span></span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token maybe-class-name">OnChanges</span></span> <span class="token punctuation">{</span>
  @<span class="token function"><span class="token maybe-class-name">Input</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  @<span class="token function"><span class="token maybe-class-name">Input</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> email<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>

  <span class="token keyword">private</span> username$ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token maybe-class-name">Subject</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token operator">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">ngOnChanges</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">,</span> email <span class="token punctuation">}</span><span class="token operator">:</span> <span class="token maybe-class-name">SimpleChanges</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> username <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token property-access">currentValue</span> <span class="token operator">||</span> email<span class="token punctuation">.</span><span class="token property-access">currentValue</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">username$</span><span class="token punctuation">.</span><span class="token method function property-access">next</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>In this case, it's fairly straightforward and simpler to receive all the inputs at once.</p><p>But because this situation is pretty uncommon, and sometimes a sign of a <em>code-smell</em>, you'll find yourselves wanting to use the setter the majority of the time.</p><p>At the end of the day, remember that this decision is always up to you and your team's preferences.</p><p><em>Thank you for reading, I hope you enjoyed this article. If you did, consider follow me on <a href="https://twitter.com/gc_psk">Twitter</a> or sign up to the Newsletter using the form below!</em></p></section><div><script async data-uid="3e3126f064" src="https://thoughtful-inventor-7842.ck.page/3e3126f064/index.js"></script></div><div class="text-sm mt-2">Do you want to report something incorrect? Please open an Issue or a PR on <a class="underline" href="https://github.com/Gbuomprisco/angularbites.com">Github</a></div><footer class="mt-5 pb-5 mb-10"><a class="underline" href="/">Back to home</a></footer></article></div><script async data-uid="da0d688ec8" src="https://thoughtful-inventor-7842.ck.page/da0d688ec8/index.js"></script><link href="https://fonts.googleapis.com/css2?family=Martel:wght@400;700;800&display=swap" rel="stylesheet"></body></html>