<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="apple-touch-icon" href="/assets/images/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicon-16x16.png"><link rel="icon" href="/assets/images/favicon.ico"><title>Unit Testing Principles with Angular</title><meta name="description" content="Unit Testing is not easy, but Angular provides us with the tools to improve the testability of our apps. This post explains how to use them."><meta name="author" content="Giancarlo Buomprisco"><meta property="og:title" content="Unit Testing Principles with Angular"><meta property="og:description" content="Unit Testing is not easy, but Angular provides us with the tools to improve the testability of our apps. This post explains how to use them."><meta property="og:locale" content="en"><meta property="og:site_name" content="Angular Bites"><meta property="og:type" content="article"><meta name="twitter:image" property="og:image" content="https://angularbites.com/assets/images/posts/unit-testing-principles.png"><meta property="twitter:title" content="Unit Testing Principles with Angular"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:creator" content="@gc_psk"><meta property="twitter:description" content="Unit Testing is not easy, but Angular provides us with the tools to improve the testability of our apps. This post explains how to use them."><meta property="og:url" content="https://angularbites.com/unit-testing-principles-with-angular/"><meta property="article:published_time" content="2021-02-07T00:00:00.000Z"><script type="application/ld+json">{
"description": "Unit Testing is not easy, but Angular provides us with the tools to improve the testability of our apps. This post explains how to use them.",
"author": { "@type": "Person", "name": "Giancarlo Buomprisco" },
"@type": "BlogPosting",
"url": "https://angularbites.com/unit-testing-principles-with-angular/",
"publisher": {
"@type": "Organization",
"logo": {
"@type": "ImageObject",
"url": "https://angularbites.com/assets/images/logo.png"
},
"name": "Giancarlo Buomprisco"
},
"headline": "Unit Testing Principles with Angular",
"datePublished": "2021-02-07T00:00:00.000Z",
"mainEntityOfPage": {
"@type": "WebPage",
"@id": "https://angularbites.com/unit-testing-principles-with-angular/"
},
"@context": "http://schema.org"
}</script><link href="/assets/styles/main.css" rel="stylesheet"></head><body><div class="container mx-auto pt-8"><header class="flex items-center"><h1 class="text-4xl my-0"><a class="site-name flex items-center" href="/"><img class="logo" alt="Logo" src="/assets/images/logo.png"></a></h1><div class="flex justify-end flex-grow"><nav class="flex main-navigation"><a class="p-4 hidden sm:block" href="/free-angular-code-review/" target="_blank">Code Reviews </a><a class="p-4" href="/contacts.html">Contacts</a></nav></div></header><article class="post pt-4"><header class="mb-8"><h1 class="post-title">Unit Testing Principles with Angular</h1><div class="block items-center md:flex justify-center"><div class="user-image flex items-center"><a target="_blank" href="https://twitter.com/@gc_psk" class="flex items-center"><img src="/assets/images/giancarlo.jpeg"> <span class="ml-2 text-gray-600 text-sm">@gc_psk</span> </a><span class="text-gray-600 text-400 ml-1">/ February 7, 2021</span></div><div class="mt-2 md:ml-5 md:mt-0"><a href="/tags/testing" class="tag-item text-xs">testing </a><a href="/tags/angular" class="tag-item text-xs">angular</a></div></div><div class="featured-image mb-8 mt-8 hidden md:block"><img src="/assets/images/posts/unit-testing-principles.png"></div></header><section class="pb-3"><p>Unit Testing is essential for writing applications that stay resilient and are well-architected. The problem is, unit testing is anything but easy - TDD or not TDD.</p><p>In this article, I want to introduce you to some fundamental principles to help you write <strong>more testable code</strong> and <em>better unit tests</em> , based on my personal experiences working on many enterprise applications.</p><p>By the end of this article, you'll be more confident knowing what to test and how to do it. If you're not, I failed, and you should definitely <a href="mailto:coaching@angularbites.com">shoot me an email</a> to let me know!</p><h2>The Basics of Angular Unit Testing</h2><h3>Why do we unit-test?</h3><p>Let's start with some bad news: unit testing does not help with regressions or spot bugs. Not as much as you'd think. I don't recall many instances where unit testing actually did spot a bug.</p><p>It's not why I write unit-tests: I'm 100% sure that a bunch of Cypress tests is going to be more helpful in spotting regressions.</p><p>So why do we do that?</p><p>Unit testing and TDD <strong>help us design code</strong>: if we find it hard to write a test, it's likely a design problem. I rarely feel 100% confident that a fully unit-tested code does not contain any bug, but I am confident that I designed it fairly well.</p><p>A <strong>unit-test is proof of an unknown presence of bugs</strong>, rather than proof of their absence. We don't know if there's a bug in our code, but we do know that we tested the absence of bugs in a number of scenarios.</p><p>If a new bug is found, we can verify the presence by writing a test-case that supposedly will fail.</p><h3>How does Angular help?</h3><p>Angular has been designed with testability in mind from the ground up. The Dependency Injection (DI) baked in Angular is a powerful ally for <strong>writing unit-tests almost effortlessly</strong> (with enough practice).</p><p>Thanks to the DI, we can mock or replace the dependencies and <strong>test the unit in isolation</strong>. Before you scream at me that &quot;by mocking you're not testing&quot; hold on, I'll explain shortly.</p><p>The whole point of a unit test is to test a <strong>specific unit</strong> and that unit alone, not integrating different units (which is instead something we do when <em>integration testing</em>).</p><p><em>Unit tests</em> should be isolated, independent, and fast. To achieve that, we mock or configure the dependencies using DI.</p><h3>Mocking - Good? Bad? Why?</h3><p>Mocking is a code smell - and should be avoided as much as possible... if you're mocking the wrong things.</p><p>When unit testing, <strong>some mocking is inevitable and even encouraged</strong>. This is highly controversial, so I'll try to be as specific as possible.</p><p>When we test a unit, we will want to mock the dependencies of that unit.</p><p>This assumes a couple of things:</p><ul><li>the interfaces are well-written and coherent</li><li>the dependencies are also well-tested</li></ul><h4>What should you mock then?</h4><p>Here is a pretty simple checklist:</p><ul><li>dependencies that contain dynamic data (e.g. a service that retrieves data from a client)</li><li>clients that connect to some external source (HTTP, Firestore, DBs, etc.)</li></ul><h4>What should you NOT mock?</h4><p>I don't generally mock services that are pure or generally algorithmic unless they have a complex setup (which they shouldn't have).</p><p>Given a specific unit, do not mock anything that is defined internally to that unit. I have seen many times private methods mocked in the test of the same <em>service</em>.</p><p>Yeah - I wouldn't mock that. Don't mock private methods.</p><p>There are better ways:</p><ul><li>Extract the method to its own unit (ex. a function, another service) and test it separately</li><li>Once you have thoroughly tested that unit works, you could mock it for the other service, but you'd have to have good reasons for doing so</li></ul><p>The fact you may want to mock a method is a decent indicator of a code smell/design problem.</p><pre class="language-typescript"><code class="language-typescript"><span class="token comment">// code smell spotted!</span>

<span class="token keyword">const</span> method <span class="token operator">=</span> <span class="token function">spyOn</span><span class="token punctuation">(</span><span class="token punctuation">(</span>service <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'doAction'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// ...</span>

<span class="token function">expect</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">toHaveBeenCalled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4>Spies</h4><p>Spies are tools used in unit-testing that help us control and test calls on <em>functions</em> so we can mock the implementation, check the parameters being passed to it, or check how many times the spy was called.</p><p>In short, they're reasonably helpful - but I do not use them very often. <em>Spies</em> are not a silver bullet and should be used in only a subset of situations:</p><ul><li>when you don't care much for the result because it's unit tested separately</li><li>when you care deeply about the correct parameters being passed to your spy, e.g. when you're testing that the parameters match what you expect, because it's the point of the unit test</li></ul><p>A spy is a last-resort kind of thing - they're convenient but only in particular situations and shouldn't be part of your toolset until you have tried different options (such as <em>extracting</em>, as suggested above).</p><h3>100% Code Coverage - does it matter?</h3><p>Generally - yes. A high coverage shows the code is likely quite easy to test, and it may prove that it works as intended in many situations.</p><p>Said that, getting to the magical 100% score is not easy - and sometimes can lead engineers to taking shortcuts.</p><p>People much smarter than me agree that trying to score 100% code coverage could make your code less readable or sacrifice architecture, which sort of defeats the point. At the end of the day, unit testing should help your design, but not impose it.</p><p>You will eventually notice it yourself. My suggestion is to not obsess too much over it, especially if not critical.</p><h2>Testing Services</h2><h3>Classes vs Functions</h3><h2>Testing Components</h2><h2>Integration tests</h2><h2>Final Words</h2><hr><p><em>If you enjoyed this article, follow me on <a href="https://twitter.com/gc_psk">Twitter</a></em></p></section><div class="text-sm mt-2">Do you want to report something incorrect? Please open an Issue or a PR on <a class="underline" href="https://github.com/Gbuomprisco/angularbites.com">Github</a></div><footer class="mt-5 pb-5 mb-10"><a class="underline" href="/">Back to home</a></footer></article></div><link href="https://fonts.googleapis.com/css2?family=Martel:wght@400;700;800&display=swap" rel="stylesheet"></body></html>