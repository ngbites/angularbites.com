<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="apple-touch-icon" href="/assets/images/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicon-16x16.png"><link rel="icon" href="/assets/images/favicon.ico"><title>The pillars of performant Angular apps</title><meta name="description" content="The pillars of achieving good performance with Angular apps"><meta name="author" content="Giancarlo Buomprisco"><meta property="og:title" content="The pillars of performant Angular apps"><meta property="og:description" content="The pillars of achieving good performance with Angular apps"><meta property="og:locale" content="en"><meta property="og:site_name" content="Angular Bites"><meta property="og:type" content="article"><meta name="twitter:image" property="og:image" content="https://angularbites.com/assets/images/posts/unit-testing-principles.png"><meta property="twitter:title" content="The pillars of performant Angular apps"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:creator" content="@gc_psk"><meta property="twitter:description" content="The pillars of achieving good performance with Angular apps"><meta property="og:url" content="https://angularbites.com/performant-angular-apps/"><meta property="article:published_time" content="2022-01-13T00:00:00.000Z"><script type="application/ld+json">{
"description": "The pillars of achieving good performance with Angular apps",
"author": { "@type": "Person", "name": "Giancarlo Buomprisco" },
"@type": "BlogPosting",
"url": "https://angularbites.com/performant-angular-apps/",
"publisher": {
"@type": "Organization",
"logo": {
"@type": "ImageObject",
"url": "https://angularbites.com/assets/images/logo.png"
},
"name": "Giancarlo Buomprisco"
},
"headline": "The pillars of performant Angular apps",
"datePublished": "2022-01-13T00:00:00.000Z",
"mainEntityOfPage": {
"@type": "WebPage",
"@id": "https://angularbites.com/performant-angular-apps/"
},
"@context": "http://schema.org"
}</script><link href="/assets/styles/main.css" rel="stylesheet"></head><body><div class="container mx-auto pt-8"><header class="flex items-center"><h1 class="text-4xl my-0"><a class="site-name flex items-center" href="/"><img class="logo" alt="Logo" src="/assets/images/logo.png"></a></h1><div class="flex justify-end flex-grow"><nav class="flex main-navigation"><a class="p-4 hidden sm:block" href="/free-angular-code-review/" target="_blank">Code Reviews </a><a class="p-4" href="/contacts.html">Contacts</a></nav></div></header><article class="post pt-4"><header class="mb-8"><h1 class="post-title">The pillars of performant Angular apps</h1><div class="block items-center md:flex justify-center"><div class="user-image flex items-center"><a target="_blank" href="https://twitter.com/@gc_psk" class="flex items-center"><img src="/assets/images/giancarlo.jpeg"> <span class="ml-2 text-gray-600 text-sm">@gc_psk</span> </a><span class="text-gray-600 text-400 ml-1">/ January 13, 2022</span></div><div class="mt-2 md:ml-5 md:mt-0"><a href="/tags/angular" class="tag-item text-xs">angular </a><a href="/tags/performance" class="tag-item text-xs">performance</a></div></div><div class="featured-image mb-8 mt-8 hidden md:block"><img src="/assets/images/posts/unit-testing-principles.png"></div></header><section class="pb-3"><p>Angular is a fast, performant framework. While not the fastest out there, it is arguably on par with React, the most popular front-end framework.</p><p>The documentation for writing faster Angular apps is certainly not lacking: a simple Google search will return hundreds of results, good and bad.</p><p>With that said, I am often contacted by many people asking me for help with their performance woes.</p><p>In this post, I want to highlight the pillars for writing performant Angular apps and help you skyrocket the user-experience for your customers.</p><p>I can summarise this post into two main goals:</p><ul><li><p>rendering less</p></li><li><p>rendering less often</p></li></ul><h2>1. Rendering Less</h2><p>How much we render on-screen at once is one of the most significant issues that cause our apps to work poorly.</p><p>Very clearly, this is often caused by a repeated list of complex, heavy components. Rendering thousands of elements may seem like a simple task for modern CPUs and browsers, but when these are complex, there is actually a lot going on.</p><p>No unbelievably fast framework will fix this: given a large enough list, the user's browser will get stuck, and the UX will be disappointing as a result.</p><p>This may sound obvious, but you'd be surprised by how many times I have seen large lists rendered without any sort of virtualization or pagination.</p><h3>So, how do you render less?</h3><p>Ask yourself the following questions:</p><ul><li><p>Will all the elements be visible on screen?</p></li><li><p>Do all the components need to be interactive right away?</p></li></ul><p>Rendering is heavy, and if something gets rendered when not in the user's viewport, it can be skipped until the user scrolls near the element.</p><p>Modern browsers support the * fantastic* Intersection Observer API, which you could use to monitor whether the component is visible or not.</p><p>By rendering the component in the viewport, you effectively save a ton of computation, avoiding too much strain on the main thread, the primary cause of laggy user interfaces.</p><p>I know there is very little related to Angular here. But here's the thing: this is true for just about any technology. I will talk about how to achieve this effectively and quickly with Angular, but it's a principle you should consider for writing all sorts of UIs.</p><h2>2. Rendering Less Often</h2><p>The second primary principle is to render less often.</p><p>Modern frameworks help us write very reactive interfaces, but unfortunately, there is a ton of work that frameworks have to repeat to achieve such magic.</p><p>That means we often recompute and re-render things that have already been computed or rendered.</p><p>Angular offers a couple of opt-in optimizations to help with these issues:</p><ul><li><p>trackBy on lists</p></li><li><p>On Push change detection</p></li></ul><p>There is a silly amount of information on the Internet about the two concepts above, so I won't bore you with the details. But they're the basic, most essential optimizations you should be making to avoid recomputations.</p><p>Sometimes, though, rendering too often is a feature: for example, in the case of high-frequency pricing, you cannot display them too late.</p><p>This is one of the (few) cases when I suggest disabling Zone.js altogether by un-patching one of the events (such as WebSockets).</p><p>You can replace it easily by using community libraries such as <a href="https://github.com/rx-angular/rx-angular">Rx-Angular</a> that make it very easy to increase your app's performance right away.</p><h2>Final Words</h2><hr><p><em>If you enjoyed this article, follow me on <a href="https://twitter.com/gc_psk">Twitter</a></em></p></section><div class="text-sm mt-2">Do you want to report something incorrect? Please open an Issue or a PR on <a class="underline" href="https://github.com/Gbuomprisco/angularbites.com">Github</a></div><footer class="mt-5 pb-5 mb-10"><a class="underline" href="/">Back to home</a></footer></article></div><link href="https://fonts.googleapis.com/css2?family=Martel:wght@400;700;800&display=swap" rel="stylesheet"></body></html>