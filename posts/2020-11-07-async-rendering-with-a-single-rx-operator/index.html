<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="apple-touch-icon" href="/assets/images/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicon-16x16.png"><link rel="icon" href="/assets/images/favicon.ico"><title>Async Rendering with a single Rx Operator</title><meta name="description" content="Increase your app rendering performance with this simple Rx operator"><meta name="author" content="Giancarlo Buomprisco"><meta property="og:title" content="Async Rendering with a single Rx Operator"><meta property="og:description" content="Increase your app rendering performance with this simple Rx operator"><meta property="og:locale" content="en"><meta property="og:site_name" content="Angular Bites"><link href="/assets/styles/main.3ea4b3fc546a4b070e9a.css" rel="stylesheet"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-172483071-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-172483071-1")</script></head><body><p>The concept of async rendering, in the way I mean it, is simple: the process of rendering items on screen is scattered so that the browser won't block until all items have been rendered.</p><p>So here's how it works: I render item one, then I wait a little bit, then render the next item, and so on. In between, the browser can execute all the other scheduled events in the loop before we let it render again.</p><h3>When and Why you should use it, sometimes</h3><p>When does this work (particularly) well?</p><ul><li>In case we are rendering particularly long and heavy lists</li><li>In case each item of the list takes a lot of space on the page</li></ul><p>Why? Your app will &quot;look&quot; faster. It's not going to be <em>actually</em> faster, but your users will perceive it as being so. Good enough.</p><h3>A single-operator approach</h3><p>In the past I've solved this in various ways, as I described in <a href="https://blog.bitsrc.io/3-ways-to-render-large-lists-in-angular-9f4dcb9b65">How to Render Large Lists in Angular</a>.</p><p>This time I thought of a single operator that would sequentially scatter the rendering process of a subset of the array.</p><p>We'll call this operator <code>lazyArray</code>. It supports two arguments:</p><ul><li><code>delayMs</code> = how long the browser should wait before it renders the next array</li><li><code>concurrency</code> = how many items to render at once</li></ul><p>Just show me the code, Giancarlo!</p><p>Alright, here it is:</p><pre class="language-typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">lazyArray</span><span class="token generic class-name"><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>
  delayMs <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
  concurrency <span class="token operator">=</span> <span class="token number">2</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> isFirstEmission <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>source$<span class="token operator">:</span> <span class="token maybe-class-name">Observable</span><span class="token operator">&#x3C;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> source$<span class="token punctuation">.</span><span class="token method function property-access">pipe</span><span class="token punctuation">(</span>
      <span class="token function">mergeMap</span><span class="token punctuation">(</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isFirstEmission<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token keyword">of</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">const</span> items$ <span class="token operator">=</span> <span class="token keyword">from</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> items$<span class="token punctuation">.</span><span class="token method function property-access">pipe</span><span class="token punctuation">(</span>
          <span class="token function">bufferCount</span><span class="token punctuation">(</span>concurrency<span class="token punctuation">)</span><span class="token punctuation">,</span>
          <span class="token function">concatMap</span><span class="token punctuation">(</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> delayed <span class="token operator">=</span> <span class="token function">delay</span><span class="token punctuation">(</span>index <span class="token operator">*</span> delayMs<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">return</span> <span class="token function">scheduled</span><span class="token punctuation">(</span><span class="token keyword">of</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span> animationFrameScheduler<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">pipe</span><span class="token punctuation">(</span>delayed<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
          <span class="token function">scan</span><span class="token punctuation">(</span><span class="token punctuation">(</span>acc<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> steps<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span> <span class="token spread operator">...</span>acc<span class="token punctuation">,</span> <span class="token spread operator">...</span>steps <span class="token punctuation">]</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
          <span class="token function">tap</span><span class="token punctuation">(</span><span class="token punctuation">(</span>scannedItems<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> scanDidComplete <span class="token operator">=</span> scannedItems<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">===</span> items<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>scanDidComplete<span class="token punctuation">)</span> <span class="token punctuation">{</span>
              isFirstEmission <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><h3>Usage</h3><p>Using it is pretty simple, use it just like any other operator:</p><pre class="language-typescript"><code class="language-typescript">@<span class="token function"><span class="token maybe-class-name">Component</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token maybe-class-name">MyComponent</span></span> <span class="token punctuation">{</span>
   items$ <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">service</span><span class="token punctuation">.</span><span class="token property-access">items$</span><span class="token punctuation">.</span><span class="token method function property-access">pipe</span><span class="token punctuation">(</span>
     <span class="token function">lazyArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><h3>Let's break it down, shall we?</h3><p>We want to keep track whether it's the first emission, or not. We only want to render lazily the first time:</p><pre class="language-typescript"><code class="language-typescript"><span class="token keyword">let</span> isFirstEmission <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></code></pre><p>We transform the array into a stream of items:</p><pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> items$ <span class="token operator">=</span> <span class="token keyword">from</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>We collect the amount of items into an array based on the concurrency:</p><pre class="language-typescript"><code class="language-typescript"><span class="token function">bufferCount</span><span class="token punctuation">(</span>concurrency<span class="token punctuation">)</span><span class="token punctuation">,</span></code></pre><p>We scheduled the rendering based on the delay, and then progressively increase the delay based on the item's index:</p><pre class="language-typescript"><code class="language-typescript"><span class="token function">concatMap</span><span class="token punctuation">(</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> delayed <span class="token operator">=</span> <span class="token function">delay</span><span class="token punctuation">(</span>index <span class="token operator">*</span> delayMs<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token function">scheduled</span><span class="token punctuation">(</span><span class="token keyword">of</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span> animationFrameScheduler<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">pipe</span><span class="token punctuation">(</span>delayed<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>We keep collecting the processed items into a single array:</p><pre class="language-typescript"><code class="language-typescript"><span class="token function">scan</span><span class="token punctuation">(</span><span class="token punctuation">(</span>acc<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> steps<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span> <span class="token spread operator">...</span>acc<span class="token punctuation">,</span> <span class="token spread operator">...</span>steps <span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>Finally, we check if the amount of processed items is as long as the initial list. In this way, we can understand if the first emission is complete, and in case we set the flag to <code>false</code>:</p><pre class="language-typescript"><code class="language-typescript"><span class="token function">tap</span><span class="token punctuation">(</span><span class="token punctuation">(</span>scannedItems<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> scanDidComplete <span class="token operator">=</span> scannedItems<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">===</span> items<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>scanDidComplete<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    isFirstEmission <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h2>Demo</h2><p>I came up with this because my application, Formtoro, loads quite a bit of data at startup that renders lots of Stencil components at once.</p><p>It did not work well, it was laggy. I didn't like it, so I found a way to solve it. I'll show you the differences:</p><p>Without <code>lazyArray</code> operator:</p><p><img src="/assets/images/posts/no-lazy-array.gif" alt="Without Lazy Array"></p><p>With <code>lazyArray</code> operator:</p><p><img src="/assets/images/posts/lazy-array.gif" alt="With Lazy Array"></p><p>This approach works very well in my case - and may not in yours. Shoot me an email if you want help implementing it. Ciao!</p><hr><p><em>If you enjoyed this article, follow me on <a href="https://twitter.com/gc_psk">Twitter</a></em></p><script async data-uid="da0d688ec8" src="https://thoughtful-inventor-7842.ck.page/da0d688ec8/index.js"></script><link href="https://fonts.googleapis.com/css2?family=Martel:wght@400;700;800&display=swap" rel="stylesheet"></body></html>